{"ast":null,"code":"\"use strict\";\n\nvar d = Object.defineProperty;\nvar b = Object.getOwnPropertyDescriptor;\nvar n = (s, a, e, t) => {\n  for (var i = t > 1 ? void 0 : t ? b(a, e) : a, o = s.length - 1, r; o >= 0; o--) (r = s[o]) && (i = (t ? r(a, e, i) : r(i)) || i);\n  return t && i && d(a, e, i), i;\n};\nimport { SpectrumElement as h } from \"@spectrum-web-components/base\";\nimport { property as l } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { FocusVisiblePolyfillMixin as m } from \"./focus-visible.js\";\nfunction u() {\n  return new Promise(s => requestAnimationFrame(() => s()));\n}\nexport class Focusable extends m(h) {\n  constructor() {\n    super(...arguments);\n    this.disabled = !1;\n    this.autofocus = !1;\n    this._tabIndex = 0;\n    this.manipulatingTabindex = !1;\n    this.autofocusReady = Promise.resolve();\n  }\n  get tabIndex() {\n    if (this.focusElement === this) {\n      const t = this.hasAttribute(\"tabindex\") ? Number(this.getAttribute(\"tabindex\")) : NaN;\n      return isNaN(t) ? -1 : t;\n    }\n    const e = parseFloat(this.hasAttribute(\"tabindex\") && this.getAttribute(\"tabindex\") || \"0\");\n    return this.disabled || e < 0 ? -1 : this.focusElement ? this.focusElement.tabIndex : e;\n  }\n  set tabIndex(e) {\n    if (this.manipulatingTabindex) {\n      this.manipulatingTabindex = !1;\n      return;\n    }\n    if (this.focusElement === this) {\n      if (e !== this._tabIndex) {\n        this._tabIndex = e;\n        const t = this.disabled ? \"-1\" : \"\" + e;\n        this.manipulatingTabindex = !0, this.setAttribute(\"tabindex\", t);\n      }\n      return;\n    }\n    if (e === -1 ? this.addEventListener(\"pointerdown\", this.onPointerdownManagementOfTabIndex) : (this.manipulatingTabindex = !0, this.removeEventListener(\"pointerdown\", this.onPointerdownManagementOfTabIndex)), e === -1 || this.disabled) {\n      this.setAttribute(\"tabindex\", \"-1\"), this.removeAttribute(\"focusable\"), e !== -1 && this.manageFocusElementTabindex(e);\n      return;\n    }\n    this.setAttribute(\"focusable\", \"\"), this.hasAttribute(\"tabindex\") ? this.removeAttribute(\"tabindex\") : this.manipulatingTabindex = !1, this.manageFocusElementTabindex(e);\n  }\n  onPointerdownManagementOfTabIndex() {\n    this.tabIndex === -1 && setTimeout(() => {\n      this.tabIndex = 0, this.focus({\n        preventScroll: !0\n      }), this.tabIndex = -1;\n    });\n  }\n  async manageFocusElementTabindex(e) {\n    this.focusElement || (await this.updateComplete), e === null ? this.focusElement.removeAttribute(\"tabindex\") : this.focusElement.tabIndex = e;\n  }\n  get focusElement() {\n    throw new Error(\"Must implement focusElement getter!\");\n  }\n  focus(e) {\n    this.disabled || !this.focusElement || (this.focusElement !== this ? this.focusElement.focus(e) : HTMLElement.prototype.focus.apply(this, [e]));\n  }\n  blur() {\n    const e = this.focusElement || this;\n    e !== this ? e.blur() : HTMLElement.prototype.blur.apply(this);\n  }\n  click() {\n    if (this.disabled) return;\n    const e = this.focusElement || this;\n    e !== this ? e.click() : HTMLElement.prototype.click.apply(this);\n  }\n  manageAutoFocus() {\n    this.autofocus && (this.dispatchEvent(new KeyboardEvent(\"keydown\", {\n      code: \"Tab\"\n    })), this.focusElement.focus());\n  }\n  firstUpdated(e) {\n    super.firstUpdated(e), (!this.hasAttribute(\"tabindex\") || this.getAttribute(\"tabindex\") !== \"-1\") && this.setAttribute(\"focusable\", \"\");\n  }\n  update(e) {\n    e.has(\"disabled\") && this.handleDisabledChanged(this.disabled, e.get(\"disabled\")), super.update(e);\n  }\n  updated(e) {\n    super.updated(e), e.has(\"disabled\") && this.disabled && this.blur();\n  }\n  async handleDisabledChanged(e, t) {\n    const i = () => this.focusElement !== this && typeof this.focusElement.disabled != \"undefined\";\n    e ? (this.manipulatingTabindex = !0, this.setAttribute(\"tabindex\", \"-1\"), await this.updateComplete, i() ? this.focusElement.disabled = !0 : this.setAttribute(\"aria-disabled\", \"true\")) : t && (this.manipulatingTabindex = !0, this.focusElement === this ? this.setAttribute(\"tabindex\", \"\" + this._tabIndex) : this.removeAttribute(\"tabindex\"), await this.updateComplete, i() ? this.focusElement.disabled = !1 : this.removeAttribute(\"aria-disabled\"));\n  }\n  async getUpdateComplete() {\n    const e = await super.getUpdateComplete();\n    return await this.autofocusReady, e;\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.autofocus && (this.autofocusReady = new Promise(async e => {\n      await u(), await u(), e();\n    }), this.updateComplete.then(() => {\n      this.manageAutoFocus();\n    }));\n  }\n}\nn([l({\n  type: Boolean,\n  reflect: !0\n})], Focusable.prototype, \"disabled\", 2), n([l({\n  type: Boolean\n})], Focusable.prototype, \"autofocus\", 2), n([l({\n  type: Number\n})], Focusable.prototype, \"tabIndex\", 1);","map":null,"metadata":{},"sourceType":"module"}