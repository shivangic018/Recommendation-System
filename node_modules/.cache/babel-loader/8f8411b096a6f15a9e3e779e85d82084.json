{"ast":null,"code":"import { noChange as e } from \"../lit-html.js\";\nimport { directive as s, Directive as t, PartType as r } from \"../directive.js\";\nimport { getCommittedValue as l, setChildPartValue as o, insertPart as i, removePart as n, setCommittedValue as f } from \"../directive-helpers.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst u = (e, s, t) => {\n    const r = new Map();\n    for (let l = s; l <= t; l++) r.set(e[l], l);\n    return r;\n  },\n  c = s(class extends t {\n    constructor(e) {\n      if (super(e), e.type !== r.CHILD) throw Error(\"repeat() can only be used in text expressions\");\n    }\n    dt(e, s, t) {\n      let r;\n      void 0 === t ? t = s : void 0 !== s && (r = s);\n      const l = [],\n        o = [];\n      let i = 0;\n      for (const s of e) l[i] = r ? r(s, i) : i, o[i] = t(s, i), i++;\n      return {\n        values: o,\n        keys: l\n      };\n    }\n    render(e, s, t) {\n      return this.dt(e, s, t).values;\n    }\n    update(s, [t, r, c]) {\n      const d = l(s),\n        {\n          values: p,\n          keys: a\n        } = this.dt(t, r, c);\n      if (!Array.isArray(d)) return this.ut = a, p;\n      const h = this.ut ??= [],\n        v = [];\n      let m,\n        y,\n        x = 0,\n        j = d.length - 1,\n        k = 0,\n        w = p.length - 1;\n      for (; x <= j && k <= w;) if (null === d[x]) x++;else if (null === d[j]) j--;else if (h[x] === a[k]) v[k] = o(d[x], p[k]), x++, k++;else if (h[j] === a[w]) v[w] = o(d[j], p[w]), j--, w--;else if (h[x] === a[w]) v[w] = o(d[x], p[w]), i(s, v[w + 1], d[x]), x++, w--;else if (h[j] === a[k]) v[k] = o(d[j], p[k]), i(s, d[x], d[j]), j--, k++;else if (void 0 === m && (m = u(a, k, w), y = u(h, x, j)), m.has(h[x])) {\n        if (m.has(h[j])) {\n          const e = y.get(a[k]),\n            t = void 0 !== e ? d[e] : null;\n          if (null === t) {\n            const e = i(s, d[x]);\n            o(e, p[k]), v[k] = e;\n          } else v[k] = o(t, p[k]), i(s, d[x], t), d[e] = null;\n          k++;\n        } else n(d[j]), j--;\n      } else n(d[x]), x++;\n      for (; k <= w;) {\n        const e = i(s, v[w + 1]);\n        o(e, p[k]), v[k++] = e;\n      }\n      for (; x <= j;) {\n        const e = d[x++];\n        null !== e && n(e);\n      }\n      return this.ut = a, f(s, v), e;\n    }\n  });\nexport { c as repeat };","map":null,"metadata":{},"sourceType":"module"}