{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst t = globalThis,\n  i = t.trustedTypes,\n  s = i ? i.createPolicy(\"lit-html\", {\n    createHTML: t => t\n  }) : void 0,\n  e = \"$lit$\",\n  h = `lit$${Math.random().toFixed(9).slice(2)}$`,\n  o = \"?\" + h,\n  n = `<${o}>`,\n  r = document,\n  l = () => r.createComment(\"\"),\n  c = t => null === t || \"object\" != typeof t && \"function\" != typeof t,\n  a = Array.isArray,\n  u = t => a(t) || \"function\" == typeof t?.[Symbol.iterator],\n  d = \"[ \\t\\n\\f\\r]\",\n  f = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n  v = /-->/g,\n  _ = />/g,\n  m = RegExp(`>|${d}(?:([^\\\\s\"'>=/]+)(${d}*=${d}*(?:[^ \\t\\n\\f\\r\"'\\`<>=]|(\"|')|))|$)`, \"g\"),\n  p = /'/g,\n  g = /\"/g,\n  $ = /^(?:script|style|textarea|title)$/i,\n  y = t => (i, ...s) => ({\n    _$litType$: t,\n    strings: i,\n    values: s\n  }),\n  x = y(1),\n  b = y(2),\n  w = Symbol.for(\"lit-noChange\"),\n  T = Symbol.for(\"lit-nothing\"),\n  A = new WeakMap(),\n  E = r.createTreeWalker(r, 129);\nfunction C(t, i) {\n  if (!Array.isArray(t) || !t.hasOwnProperty(\"raw\")) throw Error(\"invalid template strings array\");\n  return void 0 !== s ? s.createHTML(i) : i;\n}\nconst P = (t, i) => {\n  const s = t.length - 1,\n    o = [];\n  let r,\n    l = 2 === i ? \"<svg>\" : \"\",\n    c = f;\n  for (let i = 0; i < s; i++) {\n    const s = t[i];\n    let a,\n      u,\n      d = -1,\n      y = 0;\n    for (; y < s.length && (c.lastIndex = y, u = c.exec(s), null !== u);) y = c.lastIndex, c === f ? \"!--\" === u[1] ? c = v : void 0 !== u[1] ? c = _ : void 0 !== u[2] ? ($.test(u[2]) && (r = RegExp(\"</\" + u[2], \"g\")), c = m) : void 0 !== u[3] && (c = m) : c === m ? \">\" === u[0] ? (c = r ?? f, d = -1) : void 0 === u[1] ? d = -2 : (d = c.lastIndex - u[2].length, a = u[1], c = void 0 === u[3] ? m : '\"' === u[3] ? g : p) : c === g || c === p ? c = m : c === v || c === _ ? c = f : (c = m, r = void 0);\n    const x = c === m && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    l += c === f ? s + n : d >= 0 ? (o.push(a), s.slice(0, d) + e + s.slice(d) + h + x) : s + h + (-2 === d ? i : x);\n  }\n  return [C(t, l + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\")), o];\n};\nclass V {\n  constructor({\n    strings: t,\n    _$litType$: s\n  }, n) {\n    let r;\n    this.parts = [];\n    let c = 0,\n      a = 0;\n    const u = t.length - 1,\n      d = this.parts,\n      [f, v] = P(t, s);\n    if (this.el = V.createElement(f, n), E.currentNode = this.el.content, 2 === s) {\n      const t = this.el.content.firstChild;\n      t.replaceWith(...t.childNodes);\n    }\n    for (; null !== (r = E.nextNode()) && d.length < u;) {\n      if (1 === r.nodeType) {\n        if (r.hasAttributes()) for (const t of r.getAttributeNames()) if (t.endsWith(e)) {\n          const i = v[a++],\n            s = r.getAttribute(t).split(h),\n            e = /([.?@])?(.*)/.exec(i);\n          d.push({\n            type: 1,\n            index: c,\n            name: e[2],\n            strings: s,\n            ctor: \".\" === e[1] ? k : \"?\" === e[1] ? H : \"@\" === e[1] ? I : R\n          }), r.removeAttribute(t);\n        } else t.startsWith(h) && (d.push({\n          type: 6,\n          index: c\n        }), r.removeAttribute(t));\n        if ($.test(r.tagName)) {\n          const t = r.textContent.split(h),\n            s = t.length - 1;\n          if (s > 0) {\n            r.textContent = i ? i.emptyScript : \"\";\n            for (let i = 0; i < s; i++) r.append(t[i], l()), E.nextNode(), d.push({\n              type: 2,\n              index: ++c\n            });\n            r.append(t[s], l());\n          }\n        }\n      } else if (8 === r.nodeType) if (r.data === o) d.push({\n        type: 2,\n        index: c\n      });else {\n        let t = -1;\n        for (; -1 !== (t = r.data.indexOf(h, t + 1));) d.push({\n          type: 7,\n          index: c\n        }), t += h.length - 1;\n      }\n      c++;\n    }\n  }\n  static createElement(t, i) {\n    const s = r.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n}\nfunction N(t, i, s = t, e) {\n  if (i === w) return i;\n  let h = void 0 !== e ? s._$Co?.[e] : s._$Cl;\n  const o = c(i) ? void 0 : i._$litDirective$;\n  return h?.constructor !== o && (h?._$AO?.(!1), void 0 === o ? h = void 0 : (h = new o(t), h._$AT(t, s, e)), void 0 !== e ? (s._$Co ??= [])[e] = h : s._$Cl = h), void 0 !== h && (i = N(t, h._$AS(t, i.values), h, e)), i;\n}\nclass S {\n  constructor(t, i) {\n    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = i;\n  }\n  get parentNode() {\n    return this._$AM.parentNode;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  u(t) {\n    const {\n        el: {\n          content: i\n        },\n        parts: s\n      } = this._$AD,\n      e = (t?.creationScope ?? r).importNode(i, !0);\n    E.currentNode = e;\n    let h = E.nextNode(),\n      o = 0,\n      n = 0,\n      l = s[0];\n    for (; void 0 !== l;) {\n      if (o === l.index) {\n        let i;\n        2 === l.type ? i = new M(h, h.nextSibling, this, t) : 1 === l.type ? i = new l.ctor(h, l.name, l.strings, this, t) : 6 === l.type && (i = new L(h, this, t)), this._$AV.push(i), l = s[++n];\n      }\n      o !== l?.index && (h = E.nextNode(), o++);\n    }\n    return E.currentNode = r, e;\n  }\n  p(t) {\n    let i = 0;\n    for (const s of this._$AV) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;\n  }\n}\nclass M {\n  get _$AU() {\n    return this._$AM?._$AU ?? this._$Cv;\n  }\n  constructor(t, i, s, e) {\n    this.type = 2, this._$AH = T, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$Cv = e?.isConnected ?? !0;\n  }\n  get parentNode() {\n    let t = this._$AA.parentNode;\n    const i = this._$AM;\n    return void 0 !== i && 11 === t?.nodeType && (t = i.parentNode), t;\n  }\n  get startNode() {\n    return this._$AA;\n  }\n  get endNode() {\n    return this._$AB;\n  }\n  _$AI(t, i = this) {\n    t = N(this, t, i), c(t) ? t === T || null == t || \"\" === t ? (this._$AH !== T && this._$AR(), this._$AH = T) : t !== this._$AH && t !== w && this._(t) : void 0 !== t._$litType$ ? this.$(t) : void 0 !== t.nodeType ? this.T(t) : u(t) ? this.k(t) : this._(t);\n  }\n  S(t) {\n    return this._$AA.parentNode.insertBefore(t, this._$AB);\n  }\n  T(t) {\n    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));\n  }\n  _(t) {\n    this._$AH !== T && c(this._$AH) ? this._$AA.nextSibling.data = t : this.T(r.createTextNode(t)), this._$AH = t;\n  }\n  $(t) {\n    const {\n        values: i,\n        _$litType$: s\n      } = t,\n      e = \"number\" == typeof s ? this._$AC(t) : (void 0 === s.el && (s.el = V.createElement(C(s.h, s.h[0]), this.options)), s);\n    if (this._$AH?._$AD === e) this._$AH.p(i);else {\n      const t = new S(e, this),\n        s = t.u(this.options);\n      t.p(i), this.T(s), this._$AH = t;\n    }\n  }\n  _$AC(t) {\n    let i = A.get(t.strings);\n    return void 0 === i && A.set(t.strings, i = new V(t)), i;\n  }\n  k(t) {\n    a(this._$AH) || (this._$AH = [], this._$AR());\n    const i = this._$AH;\n    let s,\n      e = 0;\n    for (const h of t) e === i.length ? i.push(s = new M(this.S(l()), this.S(l()), this, this.options)) : s = i[e], s._$AI(h), e++;\n    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);\n  }\n  _$AR(t = this._$AA.nextSibling, i) {\n    for (this._$AP?.(!1, !0, i); t && t !== this._$AB;) {\n      const i = t.nextSibling;\n      t.remove(), t = i;\n    }\n  }\n  setConnected(t) {\n    void 0 === this._$AM && (this._$Cv = t, this._$AP?.(t));\n  }\n}\nclass R {\n  get tagName() {\n    return this.element.tagName;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  constructor(t, i, s, e, h) {\n    this.type = 1, this._$AH = T, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = h, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = T;\n  }\n  _$AI(t, i = this, s, e) {\n    const h = this.strings;\n    let o = !1;\n    if (void 0 === h) t = N(this, t, i, 0), o = !c(t) || t !== this._$AH && t !== w, o && (this._$AH = t);else {\n      const e = t;\n      let n, r;\n      for (t = h[0], n = 0; n < h.length - 1; n++) r = N(this, e[s + n], i, n), r === w && (r = this._$AH[n]), o ||= !c(r) || r !== this._$AH[n], r === T ? t = T : t !== T && (t += (r ?? \"\") + h[n + 1]), this._$AH[n] = r;\n    }\n    o && !e && this.j(t);\n  }\n  j(t) {\n    t === T ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? \"\");\n  }\n}\nclass k extends R {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n  j(t) {\n    this.element[this.name] = t === T ? void 0 : t;\n  }\n}\nclass H extends R {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n  j(t) {\n    this.element.toggleAttribute(this.name, !!t && t !== T);\n  }\n}\nclass I extends R {\n  constructor(t, i, s, e, h) {\n    super(t, i, s, e, h), this.type = 5;\n  }\n  _$AI(t, i = this) {\n    if ((t = N(this, t, i, 0) ?? T) === w) return;\n    const s = this._$AH,\n      e = t === T && s !== T || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive,\n      h = t !== T && (s === T || e);\n    e && this.element.removeEventListener(this.name, this, s), h && this.element.addEventListener(this.name, this, t), this._$AH = t;\n  }\n  handleEvent(t) {\n    \"function\" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t) : this._$AH.handleEvent(t);\n  }\n}\nclass L {\n  constructor(t, i, s) {\n    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;\n  }\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n  _$AI(t) {\n    N(this, t);\n  }\n}\nconst z = {\n    P: e,\n    A: h,\n    C: o,\n    M: 1,\n    L: P,\n    R: S,\n    D: u,\n    V: N,\n    I: M,\n    H: R,\n    N: H,\n    U: I,\n    B: k,\n    F: L\n  },\n  Z = t.litHtmlPolyfillSupport;\nZ?.(V, M), (t.litHtmlVersions ??= []).push(\"3.1.4\");\nconst j = (t, i, s) => {\n  const e = s?.renderBefore ?? i;\n  let h = e._$litPart$;\n  if (void 0 === h) {\n    const t = s?.renderBefore ?? null;\n    e._$litPart$ = h = new M(i.insertBefore(l(), t), t, void 0, s ?? {});\n  }\n  return h._$AI(t), h;\n};\nexport { z as _$LH, x as html, w as noChange, T as nothing, j as render, b as svg };","map":null,"metadata":{},"sourceType":"module"}