{"ast":null,"code":"/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController {\n  constructor(host, {\n    target,\n    config,\n    callback,\n    skipInitial\n  }) {\n    this._targets = new Set();\n    this._skipInitial = false;\n    /**\n     * Flag used to help manage calling the `callback` when observe is called\n     * in addition to when a mutation occurs. This is done to help setup initial\n     * state and is performed async by requesting a host update and calling\n     * `handleChanges` once by checking and then resetting this flag.\n     */\n    this._unobservedUpdate = false;\n    this._host = host;\n    // Target defaults to `host` unless explicitly `null`.\n    if (target !== null) {\n      this._targets.add(target ?? host);\n    }\n    this._config = config;\n    this._skipInitial = skipInitial ?? this._skipInitial;\n    this.callback = callback;\n    // Check browser support.\n    if (!window.MutationObserver) {\n      console.warn(`MutationController error: browser does not support MutationObserver.`);\n      return;\n    }\n    this._observer = new MutationObserver(records => {\n      this.handleChanges(records);\n      this._host.requestUpdate();\n    });\n    host.addController(this);\n  }\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n  handleChanges(records) {\n    this.value = this.callback?.(records, this._observer);\n  }\n  hostConnected() {\n    for (const target of this._targets) {\n      this.observe(target);\n    }\n  }\n  hostDisconnected() {\n    this.disconnect();\n  }\n  async hostUpdated() {\n    // Eagerly deliver any changes that happened during update.\n    // And handle initial state as a set of 0 changes. This helps setup initial\n    // state and promotes UI = f(state) since ideally the callback does not\n    // rely on changes.\n    const pendingRecords = this._observer.takeRecords();\n    if (pendingRecords.length || !this._skipInitial && this._unobservedUpdate) {\n      this.handleChanges(pendingRecords);\n    }\n    this._unobservedUpdate = false;\n  }\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n  observe(target) {\n    this._targets.add(target);\n    this._observer.observe(target, this._config);\n    this._unobservedUpdate = true;\n    this._host.requestUpdate();\n  }\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n  disconnect() {\n    this._observer.disconnect();\n  }\n}","map":{"version":3,"names":["MutationController","constructor","host","target","config","callback","skipInitial","_targets","Set","_skipInitial","_unobservedUpdate","_host","add","_config","window","MutationObserver","console","warn","_observer","records","handleChanges","requestUpdate","addController","value","hostConnected","observe","hostDisconnected","disconnect","hostUpdated","pendingRecords","takeRecords","length"],"sources":["/Users/shivangic/Documents/Intern Project/recommendationsystem/node_modules/@lit-labs/observers/src/mutation-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {\n  ReactiveController,\n  ReactiveControllerHost,\n} from '@lit/reactive-element/reactive-controller.js';\n\n/**\n * The callback function for a MutationController.\n */\nexport type MutationValueCallback<T = unknown> = (\n  ...args: Parameters<MutationCallback>\n) => T;\n\n/**\n * The config options for a MutationController.\n */\nexport interface MutationControllerConfig<T = unknown> {\n  /**\n   * Configuration object for the MutationObserver.\n   */\n  config: MutationObserverInit;\n  /**\n   * The element to observe. In addition to configuring the target here,\n   * the `observe` method can be called to observe additional targets. When not\n   * specified, the target defaults to the `host`. If set to `null`, no target\n   * is automatically observed. Only the configured target will be re-observed\n   * if the host connects again after unobserving via disconnection.\n   */\n  target?: Element | null;\n  /**\n   * The callback used to process detected changes into a value stored\n   * in the controller's `value` property.\n   */\n  callback?: MutationValueCallback<T>;\n  /**\n   * By default the `callback` is called without changes when a target is\n   * observed. This is done to help manage initial state, but this\n   * setup step can be skipped by setting this to true.\n   */\n  skipInitial?: boolean;\n}\n\n/**\n * MutationController is a ReactiveController that integrates a MutationObserver\n * with a ReactiveControllerHost's reactive update lifecycle. This is typically\n * a ReactiveElement or LitElement. MutationObservers can be used to detect\n * arbitrary changes to DOM, including nodes being added and remove and\n * attributes changing.\n *\n * The controller can specify a `target` element to observe and the\n * configuration options to pass to the MutationObserver. The `observe`\n * method can be called to observe additional elements.\n *\n * When a change is detected, the controller's given `callback` function is\n * used to process the result into a value which is stored on the controller.\n * The controller's `value` is usable during the host's update cycle.\n */\nexport class MutationController<T = unknown> implements ReactiveController {\n  private _host: ReactiveControllerHost;\n  private _targets = new Set<Element>();\n  private _config: MutationObserverInit;\n  private _observer!: MutationObserver;\n  private _skipInitial = false;\n  /**\n   * Flag used to help manage calling the `callback` when observe is called\n   * in addition to when a mutation occurs. This is done to help setup initial\n   * state and is performed async by requesting a host update and calling\n   * `handleChanges` once by checking and then resetting this flag.\n   */\n  private _unobservedUpdate = false;\n  /**\n   * The result of processing the observer's changes via the `callback`\n   * function.\n   */\n  value?: T;\n  /**\n   * Function that returns a value processed from the observer's changes.\n   * The result is stored in the `value` property.\n   */\n  callback?: MutationValueCallback<T>;\n  constructor(\n    host: ReactiveControllerHost & Element,\n    {target, config, callback, skipInitial}: MutationControllerConfig<T>\n  ) {\n    this._host = host;\n    // Target defaults to `host` unless explicitly `null`.\n    if (target !== null) {\n      this._targets.add(target ?? host);\n    }\n    this._config = config;\n    this._skipInitial = skipInitial ?? this._skipInitial;\n    this.callback = callback;\n    // Check browser support.\n    if (!window.MutationObserver) {\n      console.warn(\n        `MutationController error: browser does not support MutationObserver.`\n      );\n      return;\n    }\n    this._observer = new MutationObserver((records: MutationRecord[]) => {\n      this.handleChanges(records);\n      this._host.requestUpdate();\n    });\n    host.addController(this);\n  }\n\n  /**\n   * Process the observer's changes with the controller's `callback`\n   * function to produce a result stored in the `value` property.\n   */\n  protected handleChanges(records: MutationRecord[]) {\n    this.value = this.callback?.(records, this._observer);\n  }\n\n  hostConnected() {\n    for (const target of this._targets) {\n      this.observe(target);\n    }\n  }\n\n  hostDisconnected() {\n    this.disconnect();\n  }\n\n  async hostUpdated() {\n    // Eagerly deliver any changes that happened during update.\n    // And handle initial state as a set of 0 changes. This helps setup initial\n    // state and promotes UI = f(state) since ideally the callback does not\n    // rely on changes.\n    const pendingRecords = this._observer.takeRecords();\n    if (\n      pendingRecords.length ||\n      (!this._skipInitial && this._unobservedUpdate)\n    ) {\n      this.handleChanges(pendingRecords);\n    }\n    this._unobservedUpdate = false;\n  }\n\n  /**\n   * Observe the target element. The controller's `target` is automatically\n   * observed when the host connects.\n   * @param target Element to observe\n   */\n  observe(target: Element) {\n    this._targets.add(target);\n    this._observer.observe(target, this._config);\n    this._unobservedUpdate = true;\n    this._host.requestUpdate();\n  }\n\n  /**\n   * Disconnects the observer. This is done automatically when the host\n   * disconnects.\n   */\n  protected disconnect() {\n    this._observer.disconnect();\n  }\n}\n"],"mappings":"AA8CA;;;;;;;;;;;;;;;AAeA,OAAM,MAAOA,kBAAkB;EAuB7BC,YACEC,IAAsC,EACtC;IAACC,MAAM;IAAEC,MAAM;IAAEC,QAAQ;IAAEC;EAAW,CAA8B;IAvB9D,KAAAC,QAAQ,GAAG,IAAIC,GAAG,EAAW;IAG7B,KAAAC,YAAY,GAAG,KAAK;IAC5B;;;;;;IAMQ,KAAAC,iBAAiB,GAAG,KAAK;IAe/B,IAAI,CAACC,KAAK,GAAGT,IAAI;IACjB;IACA,IAAIC,MAAM,KAAK,IAAI,EAAE;MACnB,IAAI,CAACI,QAAQ,CAACK,GAAG,CAACT,MAAM,IAAID,IAAI,CAAC;;IAEnC,IAAI,CAACW,OAAO,GAAGT,MAAM;IACrB,IAAI,CAACK,YAAY,GAAGH,WAAW,IAAI,IAAI,CAACG,YAAY;IACpD,IAAI,CAACJ,QAAQ,GAAGA,QAAQ;IACxB;IACA,IAAI,CAACS,MAAM,CAACC,gBAAgB,EAAE;MAC5BC,OAAO,CAACC,IAAI,CACV,sEAAsE,CACvE;MACD;;IAEF,IAAI,CAACC,SAAS,GAAG,IAAIH,gBAAgB,CAAEI,OAAyB,IAAI;MAClE,IAAI,CAACC,aAAa,CAACD,OAAO,CAAC;MAC3B,IAAI,CAACR,KAAK,CAACU,aAAa,EAAE;IAC5B,CAAC,CAAC;IACFnB,IAAI,CAACoB,aAAa,CAAC,IAAI,CAAC;EAC1B;EAEA;;;;EAIUF,aAAaA,CAACD,OAAyB;IAC/C,IAAI,CAACI,KAAK,GAAG,IAAI,CAAClB,QAAQ,GAAGc,OAAO,EAAE,IAAI,CAACD,SAAS,CAAC;EACvD;EAEAM,aAAaA,CAAA;IACX,KAAK,MAAMrB,MAAM,IAAI,IAAI,CAACI,QAAQ,EAAE;MAClC,IAAI,CAACkB,OAAO,CAACtB,MAAM,CAAC;;EAExB;EAEAuB,gBAAgBA,CAAA;IACd,IAAI,CAACC,UAAU,EAAE;EACnB;EAEA,MAAMC,WAAWA,CAAA;IACf;IACA;IACA;IACA;IACA,MAAMC,cAAc,GAAG,IAAI,CAACX,SAAS,CAACY,WAAW,EAAE;IACnD,IACED,cAAc,CAACE,MAAM,IACpB,CAAC,IAAI,CAACtB,YAAY,IAAI,IAAI,CAACC,iBAAkB,EAC9C;MACA,IAAI,CAACU,aAAa,CAACS,cAAc,CAAC;;IAEpC,IAAI,CAACnB,iBAAiB,GAAG,KAAK;EAChC;EAEA;;;;;EAKAe,OAAOA,CAACtB,MAAe;IACrB,IAAI,CAACI,QAAQ,CAACK,GAAG,CAACT,MAAM,CAAC;IACzB,IAAI,CAACe,SAAS,CAACO,OAAO,CAACtB,MAAM,EAAE,IAAI,CAACU,OAAO,CAAC;IAC5C,IAAI,CAACH,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,KAAK,CAACU,aAAa,EAAE;EAC5B;EAEA;;;;EAIUM,UAAUA,CAAA;IAClB,IAAI,CAACT,SAAS,CAACS,UAAU,EAAE;EAC7B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}