{"ast":null,"code":"import { noChange as t } from \"../lit-html.js\";\nimport { directive as s, Directive as i, PartType as r } from \"../directive.js\";\n/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst e = s(class extends i {\n  constructor(t) {\n    if (super(t), t.type !== r.ATTRIBUTE || \"class\" !== t.name || t.strings?.length > 2) throw Error(\"`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.\");\n  }\n  render(t) {\n    return \" \" + Object.keys(t).filter(s => t[s]).join(\" \") + \" \";\n  }\n  update(s, [i]) {\n    if (void 0 === this.st) {\n      this.st = new Set(), void 0 !== s.strings && (this.nt = new Set(s.strings.join(\" \").split(/\\s/).filter(t => \"\" !== t)));\n      for (const t in i) i[t] && !this.nt?.has(t) && this.st.add(t);\n      return this.render(i);\n    }\n    const r = s.element.classList;\n    for (const t of this.st) t in i || (r.remove(t), this.st.delete(t));\n    for (const t in i) {\n      const s = !!i[t];\n      s === this.st.has(t) || this.nt?.has(t) || (s ? (r.add(t), this.st.add(t)) : (r.remove(t), this.st.delete(t)));\n    }\n    return t;\n  }\n});\nexport { e as classMap };","map":{"version":3,"sources":["../src/directives/class-map.ts"],"names":["Directive","partInfo","super","type","PartType","ATTRIBUTE","name","strings","length","Error","classInfo","Object","keys","filter","key","join","part","this","_previousClasses","undefined","Set","_staticClasses","split","s","has","add","render","classList","element","remove","delete","value","noChange","classMap","directive"],"mappings":";;;;;;;MAyHaiC,CAAAA,GAAWC,CAAAA,CAnGxB,cAAgClC,CAAAA;EAQ9B,WAAA,CAAYC,CAAAA,EAAAA;IAEV,IADAC,KAAAA,CAAMD,CAAAA,CAAAA,EAEJA,CAAAA,CAASE,IAAAA,KAASC,CAAAA,CAASC,SAAAA,IACT,OAAA,KAAlBJ,CAAAA,CAASK,IAAAA,IACRL,CAAAA,CAASM,OAAAA,EAASC,MAAAA,GAAoB,CAAA,EAEvC,MAAUC,KAAAA,CACR,oGAAA,CAIL;EAAA;EAED,MAAA,CAAOC,CAAAA,EAAAA;IAEL,OACE,GAAA,GACAC,MAAAA,CAAOC,IAAAA,CAAKF,CAAAA,CAAAA,CACTG,MAAAA,CAAQC,CAAAA,IAAQJ,CAAAA,CAAUI,CAAAA,CAAAA,CAAAA,CAC1BC,IAAAA,CAAK,GAAA,CAAA,GACR,GAEH;EAAA;EAEQ,MAAA,CAAOC,CAAAA,EAAAA,CAAsBN,CAAAA,CAAAA,EAAAA;IAEpC,IAAA,KAA8BS,CAAAA,KAA1BF,IAAAA,CAAKC,EAAAA,EAAgC;MACvCD,IAAAA,CAAKC,EAAAA,GAAmB,IAAIE,GAAAA,CAAAA,CAAAA,EAAAA,KACPD,CAAAA,KAAjBH,CAAAA,CAAKT,OAAAA,KACPU,IAAAA,CAAKI,EAAAA,GAAiB,IAAID,GAAAA,CACxBJ,CAAAA,CAAKT,OAAAA,CACFQ,IAAAA,CAAK,GAAA,CAAA,CACLO,KAAAA,CAAM,IAAA,CAAA,CACNT,MAAAA,CAAQU,CAAAA,IAAY,EAAA,KAANA,CAAAA,CAAAA,CAAAA,CAAAA;MAGrB,KAAK,MAAMjB,CAAAA,IAAQI,CAAAA,EACbA,CAAAA,CAAUJ,CAAAA,CAAAA,IAAAA,CAAUW,IAAAA,CAAKI,EAAAA,EAAgBG,GAAAA,CAAIlB,CAAAA,CAAAA,IAC/CW,IAAAA,CAAKC,EAAAA,CAAiBO,GAAAA,CAAInB,CAAAA,CAAAA;MAG9B,OAAOW,IAAAA,CAAKS,MAAAA,CAAOhB,CAAAA,CACpB;IAAA;IAED,MAAMiB,CAAAA,GAAYX,CAAAA,CAAKY,OAAAA,CAAQD,SAAAA;IAG/B,KAAK,MAAMrB,CAAAA,IAAQW,IAAAA,CAAKC,EAAAA,EAChBZ,CAAAA,IAAQI,CAAAA,KACZiB,CAAAA,CAAUE,MAAAA,CAAOvB,CAAAA,CAAAA,EACjBW,IAAAA,CAAKC,EAAAA,CAAkBY,MAAAA,CAAOxB,CAAAA,CAAAA,CAAAA;IAKlC,KAAK,MAAMA,CAAAA,IAAQI,CAAAA,EAAW;MAG5B,MAAMqB,CAAAA,GAAAA,CAAAA,CAAUrB,CAAAA,CAAUJ,CAAAA,CAAAA;MAExByB,CAAAA,KAAUd,IAAAA,CAAKC,EAAAA,CAAiBM,GAAAA,CAAIlB,CAAAA,CAAAA,IACnCW,IAAAA,CAAKI,EAAAA,EAAgBG,GAAAA,CAAIlB,CAAAA,CAAAA,KAEtByB,CAAAA,IACFJ,CAAAA,CAAUF,GAAAA,CAAInB,CAAAA,CAAAA,EACdW,IAAAA,CAAKC,EAAAA,CAAiBO,GAAAA,CAAInB,CAAAA,CAAAA,KAE1BqB,CAAAA,CAAUE,MAAAA,CAAOvB,CAAAA,CAAAA,EACjBW,IAAAA,CAAKC,EAAAA,CAAiBY,MAAAA,CAAOxB,CAAAA,CAAAA,CAAAA,CAGlC;IAAA;IACD,OAAO0B,CACR;EAAA;AAAA,CAAA,CAAA;AAAA,SAAA,CAAA,IAAA,QAAA","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\n\n/**\n * A key-value set of class names to truthy values.\n */\nexport interface ClassInfo {\n  readonly [name: string]: string | boolean | number;\n}\n\nclass ClassMapDirective extends Directive {\n  /**\n   * Stores the ClassInfo object applied to a given AttributePart.\n   * Used to unset existing values when a new ClassInfo object is applied.\n   */\n  private _previousClasses?: Set<string>;\n  private _staticClasses?: Set<string>;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      partInfo.type !== PartType.ATTRIBUTE ||\n      partInfo.name !== 'class' ||\n      (partInfo.strings?.length as number) > 2\n    ) {\n      throw new Error(\n        '`classMap()` can only be used in the `class` attribute ' +\n          'and must be the only part in the attribute.',\n      );\n    }\n  }\n\n  render(classInfo: ClassInfo) {\n    // Add spaces to ensure separation from static classes\n    return (\n      ' ' +\n      Object.keys(classInfo)\n        .filter((key) => classInfo[key])\n        .join(' ') +\n      ' '\n    );\n  }\n\n  override update(part: AttributePart, [classInfo]: DirectiveParameters<this>) {\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(\n          part.strings\n            .join(' ')\n            .split(/\\s/)\n            .filter((s) => s !== ''),\n        );\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !this._staticClasses?.has(name)) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n\n    const classList = part.element.classList;\n\n    // Remove old classes that no longer apply\n    for (const name of this._previousClasses) {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses!.delete(name);\n      }\n    }\n\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (\n        value !== this._previousClasses.has(name) &&\n        !this._staticClasses?.has(name)\n      ) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {ClassMapDirective};\n"]},"metadata":{},"sourceType":"module"}