{"ast":null,"code":"import { getCompatibleStyle as t, adoptStyles as s } from \"./css-tag.js\";\nexport { CSSResult, adoptStyles, css, getCompatibleStyle, supportsAdoptingStyleSheets, unsafeCSS } from \"./css-tag.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst {\n    is: i,\n    defineProperty: e,\n    getOwnPropertyDescriptor: r,\n    getOwnPropertyNames: h,\n    getOwnPropertySymbols: o,\n    getPrototypeOf: n\n  } = Object,\n  a = globalThis,\n  c = a.trustedTypes,\n  l = c ? c.emptyScript : \"\",\n  p = a.reactiveElementPolyfillSupport,\n  d = (t, s) => t,\n  u = {\n    toAttribute(t, s) {\n      switch (s) {\n        case Boolean:\n          t = t ? l : null;\n          break;\n        case Object:\n        case Array:\n          t = null == t ? t : JSON.stringify(t);\n      }\n      return t;\n    },\n    fromAttribute(t, s) {\n      let i = t;\n      switch (s) {\n        case Boolean:\n          i = null !== t;\n          break;\n        case Number:\n          i = null === t ? null : Number(t);\n          break;\n        case Object:\n        case Array:\n          try {\n            i = JSON.parse(t);\n          } catch (t) {\n            i = null;\n          }\n      }\n      return i;\n    }\n  },\n  f = (t, s) => !i(t, s),\n  y = {\n    attribute: !0,\n    type: String,\n    converter: u,\n    reflect: !1,\n    hasChanged: f\n  };\nSymbol.metadata ??= Symbol(\"metadata\"), a.litPropertyMetadata ??= new WeakMap();\nclass b extends HTMLElement {\n  static addInitializer(t) {\n    this._$Ei(), (this.l ??= []).push(t);\n  }\n  static get observedAttributes() {\n    return this.finalize(), this._$Eh && [...this._$Eh.keys()];\n  }\n  static createProperty(t, s = y) {\n    if (s.state && (s.attribute = !1), this._$Ei(), this.elementProperties.set(t, s), !s.noAccessor) {\n      const i = Symbol(),\n        r = this.getPropertyDescriptor(t, i, s);\n      void 0 !== r && e(this.prototype, t, r);\n    }\n  }\n  static getPropertyDescriptor(t, s, i) {\n    const {\n      get: e,\n      set: h\n    } = r(this.prototype, t) ?? {\n      get() {\n        return this[s];\n      },\n      set(t) {\n        this[s] = t;\n      }\n    };\n    return {\n      get() {\n        return e?.call(this);\n      },\n      set(s) {\n        const r = e?.call(this);\n        h.call(this, s), this.requestUpdate(t, r, i);\n      },\n      configurable: !0,\n      enumerable: !0\n    };\n  }\n  static getPropertyOptions(t) {\n    return this.elementProperties.get(t) ?? y;\n  }\n  static _$Ei() {\n    if (this.hasOwnProperty(d(\"elementProperties\"))) return;\n    const t = n(this);\n    t.finalize(), void 0 !== t.l && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);\n  }\n  static finalize() {\n    if (this.hasOwnProperty(d(\"finalized\"))) return;\n    if (this.finalized = !0, this._$Ei(), this.hasOwnProperty(d(\"properties\"))) {\n      const t = this.properties,\n        s = [...h(t), ...o(t)];\n      for (const i of s) this.createProperty(i, t[i]);\n    }\n    const t = this[Symbol.metadata];\n    if (null !== t) {\n      const s = litPropertyMetadata.get(t);\n      if (void 0 !== s) for (const [t, i] of s) this.elementProperties.set(t, i);\n    }\n    this._$Eh = new Map();\n    for (const [t, s] of this.elementProperties) {\n      const i = this._$Eu(t, s);\n      void 0 !== i && this._$Eh.set(i, t);\n    }\n    this.elementStyles = this.finalizeStyles(this.styles);\n  }\n  static finalizeStyles(s) {\n    const i = [];\n    if (Array.isArray(s)) {\n      const e = new Set(s.flat(1 / 0).reverse());\n      for (const s of e) i.unshift(t(s));\n    } else void 0 !== s && i.push(t(s));\n    return i;\n  }\n  static _$Eu(t, s) {\n    const i = s.attribute;\n    return !1 === i ? void 0 : \"string\" == typeof i ? i : \"string\" == typeof t ? t.toLowerCase() : void 0;\n  }\n  constructor() {\n    super(), this._$Ep = void 0, this.isUpdatePending = !1, this.hasUpdated = !1, this._$Em = null, this._$Ev();\n  }\n  _$Ev() {\n    this._$ES = new Promise(t => this.enableUpdating = t), this._$AL = new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach(t => t(this));\n  }\n  addController(t) {\n    (this._$EO ??= new Set()).add(t), void 0 !== this.renderRoot && this.isConnected && t.hostConnected?.();\n  }\n  removeController(t) {\n    this._$EO?.delete(t);\n  }\n  _$E_() {\n    const t = new Map(),\n      s = this.constructor.elementProperties;\n    for (const i of s.keys()) this.hasOwnProperty(i) && (t.set(i, this[i]), delete this[i]);\n    t.size > 0 && (this._$Ep = t);\n  }\n  createRenderRoot() {\n    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n    return s(t, this.constructor.elementStyles), t;\n  }\n  connectedCallback() {\n    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(!0), this._$EO?.forEach(t => t.hostConnected?.());\n  }\n  enableUpdating(t) {}\n  disconnectedCallback() {\n    this._$EO?.forEach(t => t.hostDisconnected?.());\n  }\n  attributeChangedCallback(t, s, i) {\n    this._$AK(t, i);\n  }\n  _$EC(t, s) {\n    const i = this.constructor.elementProperties.get(t),\n      e = this.constructor._$Eu(t, i);\n    if (void 0 !== e && !0 === i.reflect) {\n      const r = (void 0 !== i.converter?.toAttribute ? i.converter : u).toAttribute(s, i.type);\n      this._$Em = t, null == r ? this.removeAttribute(e) : this.setAttribute(e, r), this._$Em = null;\n    }\n  }\n  _$AK(t, s) {\n    const i = this.constructor,\n      e = i._$Eh.get(t);\n    if (void 0 !== e && this._$Em !== e) {\n      const t = i.getPropertyOptions(e),\n        r = \"function\" == typeof t.converter ? {\n          fromAttribute: t.converter\n        } : void 0 !== t.converter?.fromAttribute ? t.converter : u;\n      this._$Em = e, this[e] = r.fromAttribute(s, t.type), this._$Em = null;\n    }\n  }\n  requestUpdate(t, s, i) {\n    if (void 0 !== t) {\n      if (i ??= this.constructor.getPropertyOptions(t), !(i.hasChanged ?? f)(this[t], s)) return;\n      this.P(t, s, i);\n    }\n    !1 === this.isUpdatePending && (this._$ES = this._$ET());\n  }\n  P(t, s, i) {\n    this._$AL.has(t) || this._$AL.set(t, s), !0 === i.reflect && this._$Em !== t && (this._$Ej ??= new Set()).add(t);\n  }\n  async _$ET() {\n    this.isUpdatePending = !0;\n    try {\n      await this._$ES;\n    } catch (t) {\n      Promise.reject(t);\n    }\n    const t = this.scheduleUpdate();\n    return null != t && (await t), !this.isUpdatePending;\n  }\n  scheduleUpdate() {\n    return this.performUpdate();\n  }\n  performUpdate() {\n    if (!this.isUpdatePending) return;\n    if (!this.hasUpdated) {\n      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {\n        for (const [t, s] of this._$Ep) this[t] = s;\n        this._$Ep = void 0;\n      }\n      const t = this.constructor.elementProperties;\n      if (t.size > 0) for (const [s, i] of t) !0 !== i.wrapped || this._$AL.has(s) || void 0 === this[s] || this.P(s, this[s], i);\n    }\n    let t = !1;\n    const s = this._$AL;\n    try {\n      t = this.shouldUpdate(s), t ? (this.willUpdate(s), this._$EO?.forEach(t => t.hostUpdate?.()), this.update(s)) : this._$EU();\n    } catch (s) {\n      throw t = !1, this._$EU(), s;\n    }\n    t && this._$AE(s);\n  }\n  willUpdate(t) {}\n  _$AE(t) {\n    this._$EO?.forEach(t => t.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);\n  }\n  _$EU() {\n    this._$AL = new Map(), this.isUpdatePending = !1;\n  }\n  get updateComplete() {\n    return this.getUpdateComplete();\n  }\n  getUpdateComplete() {\n    return this._$ES;\n  }\n  shouldUpdate(t) {\n    return !0;\n  }\n  update(t) {\n    this._$Ej &&= this._$Ej.forEach(t => this._$EC(t, this[t])), this._$EU();\n  }\n  updated(t) {}\n  firstUpdated(t) {}\n}\nb.elementStyles = [], b.shadowRootOptions = {\n  mode: \"open\"\n}, b[d(\"elementProperties\")] = new Map(), b[d(\"finalized\")] = new Map(), p?.({\n  ReactiveElement: b\n}), (a.reactiveElementVersions ??= []).push(\"2.0.4\");\nexport { b as ReactiveElement, u as defaultConverter, f as notEqual };","map":null,"metadata":{},"sourceType":"module"}